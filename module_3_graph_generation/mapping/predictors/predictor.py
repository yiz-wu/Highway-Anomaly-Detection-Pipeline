import numpy as np
import cv2
from typing import Union
from numpy.typing import NDArray

from ..dataloader import DataLoader

class Predictor:
    """Base class for all predictiors used to generate bev images"""

    def before_predicion(self, dataset: DataLoader, current_frame: int):
        """This function is called before predict and allows you to change the 
        camera settings for this frame or run pre processing tasks

        Note: this function is not designed to update dataset values like 
        position or rotation because by the time this function is called a 
        value for position and rotation may already be snapshotted for the 
        current frame.
        To custumize position and rotation you should extend one of the 
        dataloaders

        Args:
            dataset: dataset in use for the current generation
            current_frame: index of the current frame inside the dataset
        """
        pass

    def predict(self, img) -> NDArray:
        """Make prediction and return the output. 

        Args:
            img: data to use for prediction. Note: this may not be an image 
                depending on what you return from the dataloader

        Returns:
            prediction
        """
        raise NotImplementedError
        
    def predict_bev(self, img) -> NDArray:
        """Make prediction and return the corresponding bird eye view. 

        Args:
            img: data to use for prediction. Note: this may not be an image 
                depending on what you return from the dataloader

        Returns:
            bev warp of img. This may be a 2d integer array representing class ids
            or a 3d array with the same depth of the map
        """
        raise NotImplementedError

    def post_process_bev(self, img: NDArray) -> NDArray:
        """Run postprocessing pass on bev image.

        Args:
            img:  bev image generated by predict_bev() function

        Returns:
            bev. This may be a 2d integer array representing class ids
            or a 3d array with the same depth of the map
        """
        return img

    def get_bev_to_forward_angle(self) -> float:
        """Return angle (radians) required to make this bev point in the forward
        direction of the vehicle (usually positive x axis)
        """
        raise NotImplementedError

    def get_bev_center(self) -> Union[tuple, None]:
        """Return bev center of rotation in pixel. This is also used to position
        the bev in the map. The position supplied by the dataloders is assumed to be
        the position of this point in the world. You may need to adjust your 
        positions in the dataset to match this requirement.
        If None is returned bottom center is used in the mapping pipeline
        """
        raise NotImplementedError

    def get_map_depth(self) -> float:
        """Return map depth"""
        raise NotImplementedError

    def get_bev_size(self) -> NDArray:
        """Return bev size in pixel, this should be a 2D array"""
        raise NotImplementedError

    def get_map_resolution(self) -> float:
        """Return map resolution in meter/pixel"""
        raise NotImplementedError


##########################################################

class StandardPostProcessPredictor(Predictor):
    """Abstract predictor that offsers standard postprocessing for bevs"""

    def __init__(
        self,
        min_block_area: float = 20,
        drivable_class:int = None,
        erosion = None,
        erosion_kernel_size=(3,3)
        ) -> None:
        """Initialize

        Args:
            min_block_area: minimum valid block area that is mantained. Blocks 
                with an area lower that this value are discarded. Defaults to 20.
            drivable_class: drivable class id. Defaults to None.
            erosion: erosion morth shape. Defaults to None (no erosio).
            erosion_kernel_size: erosion kernel size. Defaults to (3,3).
        """
        self.min_block_area = min_block_area
        self.drivable_class = drivable_class
        self.erosion = erosion
        self.erosion_kernel_size = erosion_kernel_size

    def morph_shape(val):
        if val == 1:
            return cv2.MORPH_RECT
        elif val == 1:
            return cv2.MORPH_CROSS
        elif val == 2:
            return cv2.MORPH_ELLIPSE

    def post_process_bev(self, img: NDArray) -> NDArray:
        ''' Filter out small blocks and apply erosion if needed'''
        
        if self.min_block_area is None:
            return img
            
        tmp = np.copy(img)

        if self.drivable_class is not None:
            tmp[tmp == self.drivable_class] = 0

        src = (tmp != 0).astype(np.uint8)

        # search connected components inside the image : 
        #   output : An image of the same size as the input, where each pixel is labeled with the integer label of the connected component it belongs to
        #       - 0 represents the background labels
        #       - 1,2,3,... are the labels of found components
        #   stats : [left, top, width, height, area (number of pixels)] -> bounding box of each component
        #   centroids : [x, y] -> center of mass of each component
        nb_components, output, stats, centroids = cv2.connectedComponentsWithStats(src, connectivity=8)

        # get the area of each component excluding the background
        sizes = stats[1:, -1]   
        nb_components = nb_components - 1 

        # create a blank mask to keep only the components we want
        keep = np.zeros((img.shape))
        # keep components bigger than required size
        for j in range(0, nb_components):
            if sizes[j] >= self.min_block_area:
                keep[output == j + 1] = 1 
        
        if self.erosion is not None:
            element = cv2.getStructuringElement(self.erosion, self.erosion_kernel_size)
            keep = (cv2.erode(keep, element, borderType=cv2.BORDER_CONSTANT) + 0.5).astype(np.uint8)

        # add back the drivable
        if self.drivable_class is not None:
            keep[img == self.drivable_class] = 1
   

        return np.uint8(keep * img)