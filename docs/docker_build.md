
# Docker Build Instructions

This page explains how to build the four Docker images used in the HD Map Generation Pipeline.  
Each module runs inside its own container, so every image has its own Dockerfile and environment.  
You can build them all locally using the provided examples below. (assuming you are launching commands from folder's root)

---

## 1. Module — Data Preprocessing

### Description
This image handles the **alignment between GPS data and image frames**.  
It’s a lightweight Python container that runs a simple interpolation script to produce synchronized GPS–image data for the next module.

### Dockerfile
```dockerfile
# Use a lightweight Python base
FROM python:3.8-slim

# Set working directory inside container
WORKDIR /app

# Copy project files
COPY script ./script

# Default mount points for input/output
RUN mkdir -p /app/input /app/output

# Default command
ENTRYPOINT ["python", "script/interpolate_gps.py"]
````

### Build Command

```bash
docker build -t 1_data_preprocessing module_1_preprocessing/
```

---

## 2. Module — Model Inference & BEV Merging

### Description

This image runs the **segmentation model** and generates **Bird’s Eye View (BEV)** pixel maps.
It includes PyTorch, OpenCV, and all dependencies needed for model inference and BEV transformation.

### Dockerfile

```dockerfile
FROM python:3.8-slim

# 1. System deps (OpenCV, image libs, etc.)
RUN apt-get update && apt-get install -y \
    libgl1 libglib2.0-0 \
    && rm -rf /var/lib/apt/lists/*

# 2. Set workdir
WORKDIR /app

# 3. Install Python deps
COPY requirements_cv.txt .
RUN pip install --no-cache-dir -r requirements_cv.txt

# 4. Copy project
COPY mapping ./mapping
COPY models ./models
COPY script ./script

# 5. Mount points for models and data
RUN mkdir -p /app/custom_models /app/input /app/output

# 6. Default entrypoint
ENTRYPOINT ["python", "script/sdf2pixelmap.py"]
```

### Build Command

```bash
docker build -t 2_model_inference_bev_merging module_2_model_inference/
```

---

## 3. Module — Graph Generation & Processing

### Description

This image converts the **PixelMap** generated by the previous module into a **graph-based map representation** and applies postprocessing to clean and simplify the structure.
It shares many dependencies with the inference module but uses a lighter environment and dedicated graph libraries.

### Dockerfile

```dockerfile
FROM python:3.8-slim

# 1. System deps (OpenCV, image libs, etc.)
RUN apt-get update && apt-get install -y \
    libgl1 libglib2.0-0 \
    && rm -rf /var/lib/apt/lists/*

# 2. Set workdir
WORKDIR /app

# 3. Install Python deps
COPY requirements_graph.txt .
RUN pip install --no-cache-dir -r requirements_graph.txt

# 4. Copy project
COPY mapping ./mapping
COPY script ./script

# 5. Default mount points
RUN mkdir -p /app/input /app/output

# 6. Default entrypoint
ENTRYPOINT ["python", "script/pixel2graph.py"]
```

### Build Command

```bash
docker build -t 3_graph_generation_and_processing module_3_graph_generation/
```

---

## 4. Module — Lanelet2 Conversion

### Description

This image performs the **final conversion of the graph map into a Lanelet2-compatible HD map** (`.osm` + `.json`).
It is built on top of a custom **Lanelet2 base image** (usually named `lanelet2:latest`) that contains the compiled Lanelet2 libraries and ROS Noetic environment.
This stage activates a Python virtual environment inside the container to run the conversion script.

### Dockerfile

```dockerfile
# Start from the fully built Lanelet2 image
FROM lanelet2:latest

# Switch to developer user
USER developer
WORKDIR /home/developer/app

# Copy all project files
COPY --chown=developer:developer ./ ./

# Install Python venv and dependencies
RUN sudo apt-get update && sudo apt-get install -y python3-venv libgl1 libglib2.0-0 && \
    python3 -m venv linux_venv && \
    source linux_venv/bin/activate && \
    pip install --upgrade pip && \
    pip install -r requirements_cv.txt && \
    echo 'export PYTHONPATH=$PYTHONPATH:/home/developer/workspace/devel/lib/python3/dist-packages' >> linux_venv/bin/activate

# Source ROS and workspace
RUN echo "source /opt/ros/noetic/setup.bash" >> ~/.bashrc && \
    echo "source ~/workspace/devel/setup.bash" >> ~/.bashrc

# Default workdir
WORKDIR /home/developer/app

# Default entrypoint: activate venv and run Python script
ENTRYPOINT ["/bin/bash", "-c", "source linux_venv/bin/activate && python \"$@\"", "--"]
```

### Build Command

First of all, unzip the Lanelet2.zip inside the Lanelet2 folder

```bash
docker build -t lanelet2 Lanelet2/
docker build -t 4_lanelet2_conversion module_4_lanelet2_conversion/
```

> **Note:** The last module (`module_4_lanelet2_conversion`) requires a pre-built base image `lanelet2:latest`.
> You must build or download that base image first, since it contains ROS Noetic and the Lanelet2 C++ libraries required at runtime.

---

## Summary

* Each module runs independently inside its own container.
* The build process isolates dependencies to keep images modular.
* The final Lanelet2 image is the only one requiring a heavier ROS + C++ base environment.
* All images share a consistent input/output folder structure (`/app/input`, `/app/output`) and a single JSON configuration file.
